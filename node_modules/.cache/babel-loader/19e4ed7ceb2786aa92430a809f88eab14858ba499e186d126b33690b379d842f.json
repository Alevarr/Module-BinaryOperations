{"ast":null,"code":"import { Graph } from './Graph';\nimport { Node } from './Node';\nimport { Edge } from './Edge';\n\n// export class GraphGenerator {\n\n//     public static random<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false){\n//         let graph: Graph<T1, T2> = new Graph()\n//         for (let i = 0; i < n_vertex; i++){\n//             let node: Node<T1> = new Node(i.toString(), i.toString(), \"\")\n//             graph.addNode(node)\n//         }\n//         let edges_ids: number[] = [0]\n//         graph.nodes.forEach(node1 => {\n//             graph.nodes.forEach(node2 => {\n//                 if (node1.id !== node2.id) {\n//                     let prob = Math.random()\n//                     if (p_connected > prob){\n//                         let index = 1\n//                         if (edges_ids && edges_ids.at(-1)){\n//                             index = edges_ids[edges_ids.length - 1] + 1\n//                         }\n//                         edges_ids.push(index)\n//                         let edge: Edge<T1, T2> = new Edge(index.toString(), node1, node2, \"\", \"0\")\n//                         graph.addEdge(edge)\n//                     }\n//                 }\n//             });\n//         });\n//         return graph\n//     }\n\n// }\n\nexport class GraphGenerator {\n  static random(n_vertex, p_connected, selfconn = false) {\n    let graph = new Graph();\n\n    // Создаем вершины\n    for (let i = 0; i < n_vertex; i++) {\n      let node = new Node(i.toString(), i.toString(), \"\");\n      graph.addNode(node);\n    }\n\n    // Разделяем вершины на две группы для двух компонент связности\n    let half = Math.floor(n_vertex / 2);\n    let group1 = graph.nodes.slice(0, half);\n    let group2 = graph.nodes.slice(half, n_vertex);\n\n    // Функция для добавления ребер внутри группы вершин\n    function addEdges(nodes) {\n      let edges_ids = [0];\n      nodes.forEach(node1 => {\n        nodes.forEach(node2 => {\n          if (node1.id !== node2.id) {\n            let prob = Math.random();\n            if (p_connected > prob) {\n              let index = 1;\n              if (edges_ids && edges_ids.at(-1)) {\n                index = edges_ids[edges_ids.length - 1] + 1;\n              }\n              edges_ids.push(index);\n              let edge = new Edge(index.toString(), node1, node2, \"\", \"0\");\n              graph.addEdge(edge);\n            }\n          }\n        });\n      });\n    }\n\n    // Добавляем ребра в обеих группах\n    addEdges(group1);\n    addEdges(group2);\n    return graph;\n  }\n}","map":{"version":3,"names":["Graph","Node","Edge","GraphGenerator","random","n_vertex","p_connected","selfconn","graph","i","node","toString","addNode","half","Math","floor","group1","nodes","slice","group2","addEdges","edges_ids","forEach","node1","node2","id","prob","index","at","length","push","edge","addEdge"],"sources":["/home/marihuyatnik/ERW/Module-BinaryOperations/src/components/GraphLibrary/GraphGenerator.tsx"],"sourcesContent":["import { Graph } from './Graph';\nimport { Node } from './Node';\nimport { Edge } from './Edge';\n\n\n// export class GraphGenerator {\n    \n//     public static random<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false){\n//         let graph: Graph<T1, T2> = new Graph()\n//         for (let i = 0; i < n_vertex; i++){\n//             let node: Node<T1> = new Node(i.toString(), i.toString(), \"\")\n//             graph.addNode(node)\n//         }\n//         let edges_ids: number[] = [0]\n//         graph.nodes.forEach(node1 => {\n//             graph.nodes.forEach(node2 => {\n//                 if (node1.id !== node2.id) {\n//                     let prob = Math.random()\n//                     if (p_connected > prob){\n//                         let index = 1\n//                         if (edges_ids && edges_ids.at(-1)){\n//                             index = edges_ids[edges_ids.length - 1] + 1\n//                         }\n//                         edges_ids.push(index)\n//                         let edge: Edge<T1, T2> = new Edge(index.toString(), node1, node2, \"\", \"0\")\n//                         graph.addEdge(edge)\n//                     }\n//                 }\n//             });\n//         });\n//         return graph\n//     }\n\n// }\n\n\nexport class GraphGenerator {\n    \n    public static random<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false) {\n        let graph: Graph<T1, T2> = new Graph();\n        \n        // Создаем вершины\n        for (let i = 0; i < n_vertex; i++) {\n            let node: Node<T1> = new Node(i.toString(), i.toString(), \"\");\n            graph.addNode(node);\n        }\n        \n        // Разделяем вершины на две группы для двух компонент связности\n        let half = Math.floor(n_vertex / 2);\n        let group1 = graph.nodes.slice(0, half);\n        let group2 = graph.nodes.slice(half, n_vertex);\n\n        // Функция для добавления ребер внутри группы вершин\n        function addEdges(nodes: Node<T1>[]) {\n            let edges_ids: number[] = [0];\n            nodes.forEach(node1 => {\n                nodes.forEach(node2 => {\n                    if (node1.id !== node2.id) {\n                        let prob = Math.random();\n                        if (p_connected > prob) {\n                            let index = 1;\n                            if (edges_ids && edges_ids.at(-1)) {\n                                index = edges_ids[edges_ids.length - 1] + 1;\n                            }\n                            edges_ids.push(index);\n                            let edge: Edge<T1, T2> = new Edge(index.toString(), node1, node2, \"\", \"0\");\n                            graph.addEdge(edge);\n                        }\n                    }\n                });\n            });\n        }\n\n        // Добавляем ребра в обеих группах\n        addEdges(group1);\n        addEdges(group2);\n\n        return graph;\n    }\n}"],"mappings":"AAAA,SAASA,KAAK,QAAQ,SAAS;AAC/B,SAASC,IAAI,QAAQ,QAAQ;AAC7B,SAASC,IAAI,QAAQ,QAAQ;;AAG7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA,OAAO,MAAMC,cAAc,CAAC;EAExB,OAAcC,MAAMA,CAASC,QAAgB,EAAEC,WAAmB,EAAEC,QAAiB,GAAG,KAAK,EAAE;IAC3F,IAAIC,KAAoB,GAAG,IAAIR,KAAK,CAAC,CAAC;;IAEtC;IACA,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,QAAQ,EAAEI,CAAC,EAAE,EAAE;MAC/B,IAAIC,IAAc,GAAG,IAAIT,IAAI,CAACQ,CAAC,CAACE,QAAQ,CAAC,CAAC,EAAEF,CAAC,CAACE,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC;MAC7DH,KAAK,CAACI,OAAO,CAACF,IAAI,CAAC;IACvB;;IAEA;IACA,IAAIG,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACV,QAAQ,GAAG,CAAC,CAAC;IACnC,IAAIW,MAAM,GAAGR,KAAK,CAACS,KAAK,CAACC,KAAK,CAAC,CAAC,EAAEL,IAAI,CAAC;IACvC,IAAIM,MAAM,GAAGX,KAAK,CAACS,KAAK,CAACC,KAAK,CAACL,IAAI,EAAER,QAAQ,CAAC;;IAE9C;IACA,SAASe,QAAQA,CAACH,KAAiB,EAAE;MACjC,IAAII,SAAmB,GAAG,CAAC,CAAC,CAAC;MAC7BJ,KAAK,CAACK,OAAO,CAACC,KAAK,IAAI;QACnBN,KAAK,CAACK,OAAO,CAACE,KAAK,IAAI;UACnB,IAAID,KAAK,CAACE,EAAE,KAAKD,KAAK,CAACC,EAAE,EAAE;YACvB,IAAIC,IAAI,GAAGZ,IAAI,CAACV,MAAM,CAAC,CAAC;YACxB,IAAIE,WAAW,GAAGoB,IAAI,EAAE;cACpB,IAAIC,KAAK,GAAG,CAAC;cACb,IAAIN,SAAS,IAAIA,SAAS,CAACO,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE;gBAC/BD,KAAK,GAAGN,SAAS,CAACA,SAAS,CAACQ,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC;cAC/C;cACAR,SAAS,CAACS,IAAI,CAACH,KAAK,CAAC;cACrB,IAAII,IAAkB,GAAG,IAAI7B,IAAI,CAACyB,KAAK,CAAChB,QAAQ,CAAC,CAAC,EAAEY,KAAK,EAAEC,KAAK,EAAE,EAAE,EAAE,GAAG,CAAC;cAC1EhB,KAAK,CAACwB,OAAO,CAACD,IAAI,CAAC;YACvB;UACJ;QACJ,CAAC,CAAC;MACN,CAAC,CAAC;IACN;;IAEA;IACAX,QAAQ,CAACJ,MAAM,CAAC;IAChBI,QAAQ,CAACD,MAAM,CAAC;IAEhB,OAAOX,KAAK;EAChB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}