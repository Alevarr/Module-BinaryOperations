{"ast":null,"code":"import { Graph } from './Graph';\nimport { Node } from './Node';\nimport { Edge } from './Edge';\nexport class GraphGenerator {\n  static random(n_vertex, p_connected, selfconn = false) {\n    let graph = new Graph();\n    for (let i = 0; i < n_vertex; i++) {\n      let node = new Node(i.toString(), i.toString(), \"\");\n      graph.addNode(node);\n    }\n    let edges_ids = [0];\n    graph.nodes.forEach(node1 => {\n      graph.nodes.forEach(node2 => {\n        if (node1.id !== node2.id) {\n          let prob = Math.random();\n          if (p_connected > prob) {\n            let index = 1;\n            if (edges_ids && edges_ids.at(-1)) {\n              index = edges_ids[edges_ids.length - 1] + 1;\n            }\n            edges_ids.push(index);\n            let edge = new Edge(index.toString(), node1, node2, \"\", \"0\");\n            graph.addEdge(edge);\n          }\n        }\n      });\n    });\n    return graph;\n  }\n}\nexport class GraphGenerator_1 {\n  static generateTwoConnectedComponentsGraph() {\n    // Создание объекта графа\n    const graph = new Graph();\n\n    // Создание узлов для первой компоненты связности\n    const component1Size = Math.floor(Math.random() * 5) + 3; // Случайный размер первой компоненты\n    const component1Nodes = [];\n    for (let i = 0; i < component1Size; i++) {\n      const nodeId = `Node${i}`;\n      const nodeLabel = `Node ${i}`;\n      const node = new Node(nodeId, nodeLabel);\n      graph.addNode(node);\n      component1Nodes.push(node);\n    }\n\n    // Создание случайных ребер в первой компоненте\n    for (let i = 0; i < component1Size * 2; i++) {\n      const source = component1Nodes[Math.floor(Math.random() * component1Size)];\n      const target = component1Nodes[Math.floor(Math.random() * component1Size)];\n      if (source !== target) {\n        const edgeId = `Edge${i}`;\n        const edge = new Edge(edgeId, source, target);\n        graph.addEdge(edge);\n      }\n    }\n\n    // Создание узлов для второй компоненты связности\n    const component2Size = Math.floor(Math.random() * 5) + 3; // Случайный размер второй компоненты\n    const component2Nodes = [];\n    for (let i = 0; i < component2Size; i++) {\n      const nodeId = `Node${component1Size + i}`;\n      const nodeLabel = `Node ${component1Size + i}`;\n      const node = new Node(nodeId, nodeLabel);\n      graph.addNode(node);\n      component2Nodes.push(node);\n    }\n\n    // Создание случайного ребра между первой и второй компонентами\n    const source = component1Nodes[Math.floor(Math.random() * component1Size)];\n    const target = component2Nodes[Math.floor(Math.random() * component2Size)];\n    const edgeId = `Edge${component1Size * component2Size}`;\n    const edge = new Edge(edgeId, source, target);\n    graph.addEdge(edge);\n    return graph;\n  }\n}","map":{"version":3,"names":["Graph","Node","Edge","GraphGenerator","random","n_vertex","p_connected","selfconn","graph","i","node","toString","addNode","edges_ids","nodes","forEach","node1","node2","id","prob","Math","index","at","length","push","edge","addEdge","GraphGenerator_1","generateTwoConnectedComponentsGraph","component1Size","floor","component1Nodes","nodeId","nodeLabel","source","target","edgeId","component2Size","component2Nodes"],"sources":["/home/marihuyatnik/ERW/Module-BinaryOperations/src/components/GraphLibrary/GraphGenerator.tsx"],"sourcesContent":["import { Graph } from './Graph';\nimport { Node } from './Node';\nimport { Edge } from './Edge';\n\n\nexport class GraphGenerator {\n    \n    public static random<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false){\n        let graph: Graph<T1, T2> = new Graph()\n        for (let i = 0; i < n_vertex; i++){\n            let node: Node<T1> = new Node(i.toString(), i.toString(), \"\")\n            graph.addNode(node)\n        }\n        let edges_ids: number[] = [0]\n        graph.nodes.forEach(node1 => {\n            graph.nodes.forEach(node2 => {\n                if (node1.id !== node2.id) {\n                    let prob = Math.random()\n                    if (p_connected > prob){\n                        let index = 1\n                        if (edges_ids && edges_ids.at(-1)){\n                            index = edges_ids[edges_ids.length - 1] + 1\n                        }\n                        edges_ids.push(index)\n                        let edge: Edge<T1, T2> = new Edge(index.toString(), node1, node2, \"\", \"0\")\n                        graph.addEdge(edge)\n                    }\n                }\n            });\n        });\n        return graph\n    }\n\n}\n\nexport class GraphGenerator_1 {\n    static generateTwoConnectedComponentsGraph(): Graph<any, any> {\n        // Создание объекта графа\n        const graph = new Graph();\n\n        // Создание узлов для первой компоненты связности\n        const component1Size = Math.floor(Math.random() * 5) + 3; // Случайный размер первой компоненты\n        const component1Nodes = [];\n        for (let i = 0; i < component1Size; i++) {\n            const nodeId = `Node${i}`;\n            const nodeLabel = `Node ${i}`;\n            const node = new Node(nodeId, nodeLabel);\n            graph.addNode(node);\n            component1Nodes.push(node);\n        }\n\n        // Создание случайных ребер в первой компоненте\n        for (let i = 0; i < component1Size * 2; i++) {\n            const source = component1Nodes[Math.floor(Math.random() * component1Size)];\n            const target = component1Nodes[Math.floor(Math.random() * component1Size)];\n            if (source !== target) {\n                const edgeId = `Edge${i}`;\n                const edge = new Edge(edgeId, source, target);\n                graph.addEdge(edge);\n            }\n        }\n\n        // Создание узлов для второй компоненты связности\n        const component2Size = Math.floor(Math.random() * 5) + 3; // Случайный размер второй компоненты\n        const component2Nodes = [];\n        for (let i = 0; i < component2Size; i++) {\n            const nodeId = `Node${component1Size + i}`;\n            const nodeLabel = `Node ${component1Size + i}`;\n            const node = new Node(nodeId, nodeLabel);\n            graph.addNode(node);\n            component2Nodes.push(node);\n        }\n\n        // Создание случайного ребра между первой и второй компонентами\n        const source = component1Nodes[Math.floor(Math.random() * component1Size)];\n        const target = component2Nodes[Math.floor(Math.random() * component2Size)];\n        const edgeId = `Edge${component1Size * component2Size}`;\n        const edge = new Edge(edgeId, source, target);\n        graph.addEdge(edge);\n\n        return graph;\n    }\n}\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}