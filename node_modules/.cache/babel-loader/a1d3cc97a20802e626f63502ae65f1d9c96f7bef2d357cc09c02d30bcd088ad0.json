{"ast":null,"code":"import { Graph } from './Graph';\nimport { Node } from './Node';\nimport { Edge } from './Edge';\n\n// export class GraphGenerator {\n\n//     public static random<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false){\n//         let graph: Graph<T1, T2> = new Graph()\n//         for (let i = 0; i < n_vertex; i++){\n//             let node: Node<T1> = new Node(i.toString(), i.toString(), \"\")\n//             graph.addNode(node)\n//         }\n//         let edges_ids: number[] = [0]\n//         graph.nodes.forEach(node1 => {\n//             graph.nodes.forEach(node2 => {\n//                 if (node1.id !== node2.id) {\n//                     let prob = Math.random()\n//                     if (p_connected > prob){\n//                         let index = 1\n//                         if (edges_ids && edges_ids.at(-1)){\n//                             index = edges_ids[edges_ids.length - 1] + 1\n//                         }\n//                         edges_ids.push(index)\n//                         let edge: Edge<T1, T2> = new Edge(index.toString(), node1, node2, \"\", \"0\")\n//                         graph.addEdge(edge)\n//                     }\n//                 }\n//             });\n//         });\n//         return graph\n//     }\n\n// }\n\nexport class GraphGenerator {\n  static generateTwoConnectedComponentsGraph(n_vertex, p_connected, selfconn = false) {\n    const graph = new Graph();\n\n    // Создаем две компоненты связности\n    const component1 = this.randomConnectedComponent(n_vertex, p_connected, selfconn);\n    const component2 = this.randomConnectedComponent(n_vertex, p_connected, selfconn);\n\n    // Добавляем узлы и ребра из первой компоненты\n    component1.nodes.forEach(node => graph.addNode(node));\n    component1.edges.forEach(edge => graph.addEdge(edge));\n\n    // Добавляем узлы и ребра из второй компоненты\n    component2.nodes.forEach(node => graph.addNode(node));\n    component2.edges.forEach(edge => graph.addEdge(edge));\n\n    // Соединяем компоненты одним ребром\n    const nodeFromComponent1 = component1.nodes[Math.floor(Math.random() * component1.nodes.length)];\n    const nodeFromComponent2 = component2.nodes[Math.floor(Math.random() * component2.nodes.length)];\n    const edge = new Edge('EdgeBetweenComponents', nodeFromComponent1, nodeFromComponent2);\n    graph.addEdge(edge);\n    return graph;\n  }\n  static randomConnectedComponent(n_vertex, p_connected, selfconn) {\n    const component = new Graph();\n\n    // Создаем узлы\n    for (let i = 0; i < n_vertex; i++) {\n      const node = new Node(i.toString(), i.toString(), \"\");\n      component.addNode(node);\n    }\n\n    // Создаем связи между узлами\n    for (let i = 0; i < n_vertex; i++) {\n      for (let j = i + (selfconn ? 0 : 1); j < n_vertex; j++) {\n        if (Math.random() < p_connected) {\n          const source = component.nodes[i];\n          const target = component.nodes[j];\n          const edge = new Edge(`${i}_${j}`, source, target, \"\", \"0\");\n          component.addEdge(edge);\n        }\n      }\n    }\n    return component;\n  }\n}","map":{"version":3,"names":["Graph","Node","Edge","GraphGenerator","generateTwoConnectedComponentsGraph","n_vertex","p_connected","selfconn","graph","component1","randomConnectedComponent","component2","nodes","forEach","node","addNode","edges","edge","addEdge","nodeFromComponent1","Math","floor","random","length","nodeFromComponent2","component","i","toString","j","source","target"],"sources":["/home/marihuyatnik/ERW/Module-BinaryOperations/src/components/GraphLibrary/GraphGenerator.tsx"],"sourcesContent":["import { Graph } from './Graph';\nimport { Node } from './Node';\nimport { Edge } from './Edge';\n\n\n// export class GraphGenerator {\n    \n//     public static random<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false){\n//         let graph: Graph<T1, T2> = new Graph()\n//         for (let i = 0; i < n_vertex; i++){\n//             let node: Node<T1> = new Node(i.toString(), i.toString(), \"\")\n//             graph.addNode(node)\n//         }\n//         let edges_ids: number[] = [0]\n//         graph.nodes.forEach(node1 => {\n//             graph.nodes.forEach(node2 => {\n//                 if (node1.id !== node2.id) {\n//                     let prob = Math.random()\n//                     if (p_connected > prob){\n//                         let index = 1\n//                         if (edges_ids && edges_ids.at(-1)){\n//                             index = edges_ids[edges_ids.length - 1] + 1\n//                         }\n//                         edges_ids.push(index)\n//                         let edge: Edge<T1, T2> = new Edge(index.toString(), node1, node2, \"\", \"0\")\n//                         graph.addEdge(edge)\n//                     }\n//                 }\n//             });\n//         });\n//         return graph\n//     }\n\n// }\n\nexport class GraphGenerator {\n    \n    public static generateTwoConnectedComponentsGraph<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false): Graph<T1, T2> {\n        const graph: Graph<T1, T2> = new Graph();\n\n        // Создаем две компоненты связности\n        const component1 = this.randomConnectedComponent<T1, T2>(n_vertex, p_connected, selfconn);\n        const component2 = this.randomConnectedComponent<T1, T2>(n_vertex, p_connected, selfconn);\n\n        // Добавляем узлы и ребра из первой компоненты\n        component1.nodes.forEach(node => graph.addNode(node));\n        component1.edges.forEach(edge => graph.addEdge(edge));\n\n        // Добавляем узлы и ребра из второй компоненты\n        component2.nodes.forEach(node => graph.addNode(node));\n        component2.edges.forEach(edge => graph.addEdge(edge));\n\n        // Соединяем компоненты одним ребром\n        const nodeFromComponent1 = component1.nodes[Math.floor(Math.random() * component1.nodes.length)];\n        const nodeFromComponent2 = component2.nodes[Math.floor(Math.random() * component2.nodes.length)];\n        const edge = new Edge('EdgeBetweenComponents', nodeFromComponent1, nodeFromComponent2);\n        graph.addEdge(edge);\n\n        return graph;\n    }\n\n    private static randomConnectedComponent<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean): Graph<T1, T2> {\n        const component: Graph<T1, T2> = new Graph();\n\n        // Создаем узлы\n        for (let i = 0; i < n_vertex; i++) {\n            const node: Node<T1> = new Node(i.toString(), i.toString(), \"\");\n            component.addNode(node);\n        }\n\n        // Создаем связи между узлами\n        for (let i = 0; i < n_vertex; i++) {\n            for (let j = i + (selfconn ? 0 : 1); j < n_vertex; j++) {\n                if (Math.random() < p_connected) {\n                    const source = component.nodes[i];\n                    const target = component.nodes[j];\n                    const edge: Edge<T1, T2> = new Edge(`${i}_${j}`, source, target, \"\", \"0\");\n                    component.addEdge(edge);\n                }\n            }\n        }\n\n        return component;\n    }\n}\n\n\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}