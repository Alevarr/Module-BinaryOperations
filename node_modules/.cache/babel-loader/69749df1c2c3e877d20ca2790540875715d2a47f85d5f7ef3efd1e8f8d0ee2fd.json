{"ast":null,"code":"import { Graph } from './Graph';\nimport { Node } from './Node';\nimport { Edge } from './Edge';\n\n// export class GraphGenerator {\n\n//     public static random<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false){\n//         let graph: Graph<T1, T2> = new Graph()\n//         for (let i = 0; i < n_vertex; i++){\n//             let node: Node<T1> = new Node(i.toString(), i.toString(), \"\")\n//             graph.addNode(node)\n//         }\n//         let edges_ids: number[] = [0]\n//         graph.nodes.forEach(node1 => {\n//             graph.nodes.forEach(node2 => {\n//                 if (node1.id !== node2.id) {\n//                     let prob = Math.random()\n//                     if (p_connected > prob){\n//                         let index = 1\n//                         if (edges_ids && edges_ids.at(-1)){\n//                             index = edges_ids[edges_ids.length - 1] + 1\n//                         }\n//                         edges_ids.push(index)\n//                         let edge: Edge<T1, T2> = new Edge(index.toString(), node1, node2, \"\", \"0\")\n//                         graph.addEdge(edge)\n//                     }\n//                 }\n//             });\n//         });\n//         return graph\n//     }\n\n// }\n\nexport class GraphGenerator {\n  static random(n_vertex, p_connected, selfconn = false) {\n    let graph = new Graph();\n\n    // Создаем вершины\n    for (let i = 0; i < n_vertex; i++) {\n      let node = new Node(i.toString(), i.toString(), \"\");\n      graph.addNode(node);\n    }\n\n    // Создаем две компоненты связности\n    let component1 = [];\n    let component2 = [];\n\n    // Случайным образом распределяем вершины по компонентам\n    graph.nodes.forEach(node => {\n      if (Math.random() < 0.5) {\n        component1.push(node);\n      } else {\n        component2.push(node);\n      }\n    });\n\n    // Функция для добавления ребер внутри компоненты\n    function addEdges(nodes, otherComponent) {\n      let edges_ids = [0];\n      let hasOutgoingEdge = false;\n      nodes.forEach(node1 => {\n        // Проверяем, если у вершины нет исходящих ребер\n        if (!graph.edges.some(edge => edge.source.id === node1.id)) {\n          // Выбираем случайную вершину из другой компоненты\n          let randomNode = otherComponent[Math.floor(Math.random() * otherComponent.length)];\n          // Создаем ребро между этой вершиной и случайной вершиной\n          let index = edges_ids.length;\n          edges_ids.push(index);\n          let edge = new Edge(index.toString(), node1, randomNode, \"\", \"0\");\n          graph.addEdge(edge);\n          hasOutgoingEdge = true;\n        } else {\n          nodes.forEach(node2 => {\n            if (node1.id !== node2.id) {\n              let prob = Math.random();\n              if (p_connected > prob) {\n                let index = edges_ids.length;\n                edges_ids.push(index);\n                let edge = new Edge(index.toString(), node1, node2, \"\", \"0\");\n                graph.addEdge(edge);\n              }\n            }\n          });\n        }\n      });\n\n      // Если в компоненте нет вершин с исходящими ребрами, добавляем ребро из случайной вершины в другую вершину той же компоненты\n      if (!hasOutgoingEdge) {\n        let randomNode = nodes[Math.floor(Math.random() * nodes.length)];\n        let randomOtherNode = otherComponent[Math.floor(Math.random() * otherComponent.length)];\n        let index = edges_ids.length;\n        edges_ids.push(index);\n        let edge = new Edge(index.toString(), randomNode, randomOtherNode, \"\", \"0\");\n        graph.addEdge(edge);\n      }\n    }\n\n    // Добавляем ребра в обе компоненты\n    addEdges(component1, component2);\n    addEdges(component2, component1);\n    return graph;\n  }\n}","map":{"version":3,"names":["Graph","Node","Edge","GraphGenerator","random","n_vertex","p_connected","selfconn","graph","i","node","toString","addNode","component1","component2","nodes","forEach","Math","push","addEdges","otherComponent","edges_ids","hasOutgoingEdge","node1","edges","some","edge","source","id","randomNode","floor","length","index","addEdge","node2","prob","randomOtherNode"],"sources":["/home/marihuyatnik/ERW/Module-BinaryOperations/src/components/GraphLibrary/GraphGenerator.tsx"],"sourcesContent":["import { Graph } from './Graph';\nimport { Node } from './Node';\nimport { Edge } from './Edge';\n\n\n// export class GraphGenerator {\n    \n//     public static random<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false){\n//         let graph: Graph<T1, T2> = new Graph()\n//         for (let i = 0; i < n_vertex; i++){\n//             let node: Node<T1> = new Node(i.toString(), i.toString(), \"\")\n//             graph.addNode(node)\n//         }\n//         let edges_ids: number[] = [0]\n//         graph.nodes.forEach(node1 => {\n//             graph.nodes.forEach(node2 => {\n//                 if (node1.id !== node2.id) {\n//                     let prob = Math.random()\n//                     if (p_connected > prob){\n//                         let index = 1\n//                         if (edges_ids && edges_ids.at(-1)){\n//                             index = edges_ids[edges_ids.length - 1] + 1\n//                         }\n//                         edges_ids.push(index)\n//                         let edge: Edge<T1, T2> = new Edge(index.toString(), node1, node2, \"\", \"0\")\n//                         graph.addEdge(edge)\n//                     }\n//                 }\n//             });\n//         });\n//         return graph\n//     }\n\n// }\n\n\nexport class GraphGenerator {\n    \n    public static random<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false) {\n        let graph: Graph<T1, T2> = new Graph();\n        \n        // Создаем вершины\n        for (let i = 0; i < n_vertex; i++) {\n            let node: Node<T1> = new Node(i.toString(), i.toString(), \"\");\n            graph.addNode(node);\n        }\n        \n        // Создаем две компоненты связности\n        let component1: Node<T1>[] = [];\n        let component2: Node<T1>[] = [];\n        \n        // Случайным образом распределяем вершины по компонентам\n        graph.nodes.forEach(node => {\n            if (Math.random() < 0.5) {\n                component1.push(node);\n            } else {\n                component2.push(node);\n            }\n        });\n\n        // Функция для добавления ребер внутри компоненты\n        function addEdges(nodes: Node<T1>[], otherComponent: Node<T1>[]) {\n            let edges_ids: number[] = [0];\n            let hasOutgoingEdge: boolean = false;\n\n            nodes.forEach(node1 => {\n                // Проверяем, если у вершины нет исходящих ребер\n                if (!graph.edges.some(edge => edge.source.id === node1.id)) {\n                    // Выбираем случайную вершину из другой компоненты\n                    let randomNode = otherComponent[Math.floor(Math.random() * otherComponent.length)];\n                    // Создаем ребро между этой вершиной и случайной вершиной\n                    let index = edges_ids.length;\n                    edges_ids.push(index);\n                    let edge: Edge<T1, T2> = new Edge(index.toString(), node1, randomNode, \"\", \"0\");\n                    graph.addEdge(edge);\n                    hasOutgoingEdge = true;\n                } else {\n                    nodes.forEach(node2 => {\n                        if (node1.id !== node2.id) {\n                            let prob = Math.random();\n                            if (p_connected > prob) {\n                                let index = edges_ids.length;\n                                edges_ids.push(index);\n                                let edge: Edge<T1, T2> = new Edge(index.toString(), node1, node2, \"\", \"0\");\n                                graph.addEdge(edge);\n                            }\n                        }\n                    });\n                }\n            });\n\n            // Если в компоненте нет вершин с исходящими ребрами, добавляем ребро из случайной вершины в другую вершину той же компоненты\n            if (!hasOutgoingEdge) {\n                let randomNode = nodes[Math.floor(Math.random() * nodes.length)];\n                let randomOtherNode = otherComponent[Math.floor(Math.random() * otherComponent.length)];\n                let index = edges_ids.length;\n                edges_ids.push(index);\n                let edge: Edge<T1, T2> = new Edge(index.toString(), randomNode, randomOtherNode, \"\", \"0\");\n                graph.addEdge(edge);\n            }\n        }\n\n        // Добавляем ребра в обе компоненты\n        addEdges(component1, component2);\n        addEdges(component2, component1);\n\n        return graph;\n    }\n}\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}