var x = Object.defineProperty;
var d = (y, t, s) => t in y ? x(y, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : y[t] = s;
var m = (y, t, s) => (d(y, typeof t != "symbol" ? t + "" : t, s), s);
class c {
  constructor(t, s, e) {
    m(this, "_rows");
    m(this, "_columns");
    m(this, "_values");
    this._rows = Math.max(t, 1), this._columns = Math.max(s, 1), this._values = new Array(this._rows).fill([]).map(() => new Array(this._columns).fill(0)), e && (this.values = e);
  }
  get rows() {
    return this._rows;
  }
  get columns() {
    return this._columns;
  }
  get values() {
    return this._values;
  }
  set values(t) {
    const s = Math.min(t.length, this.rows), e = Math.min(t[0].length, this.columns);
    for (let r = 0; r < s; r++)
      for (let n = 0; n < e; n++)
        this.values[r][n] = t[r][n];
  }
  at(t, s) {
    return this.values[t][s];
  }
  reset() {
    this.values = this.values.map((t) => t.map(() => 0));
  }
  addAColumn() {
    return new c(this.rows, this.columns + 1, this.values);
  }
  addARow() {
    return new c(this.rows + 1, this.columns, this.values);
  }
  equals(t) {
    return this.rows === t.rows && this.columns === t.columns && this.values.reduce(
      (s, e, r) => s && e.reduce(
        (n, i, o) => n && t.at(r, o) === i,
        s
      ),
      !0
    );
  }
  setAsIdentity() {
    if (this.rows !== this.columns)
      throw new Error("Dimension error! The matrix isn't squared!");
    return this.values.forEach((t, s) => {
      t.forEach((e, r) => {
        this.values[s][r] = s === r ? 1 : 0;
      });
    }), this;
  }
  static identity(t) {
    if (t < 1)
      throw Error("Dimension error! Matrix dimension must be positive.");
    return new c(t, t).setAsIdentity();
  }
  multiply(t) {
    if (this.columns !== t.rows)
      throw new Error("Dimension error! The operand matrix must have the same number of rows as 'this' matrix columns!");
    const s = new c(this.rows, t.columns);
    return s.values = s.values.map((e, r) => e.map((n, i) => this.values[r].reduce((o, h, a) => o + h * t.at(a, i), 0))), s;
  }
  indexOf(t) {
    for (let s = 0; s < this.rows; s++)
      for (let e = 0; e < this.columns; e++)
        if (this.values[s][e] === t)
          return [s, e];
    return [-1, -1];
  }
  max() {
    return this.values.reduce((t, s) => Math.max(t, ...s), -1 / 0);
  }
  min() {
    return this.values.reduce((t, s) => Math.min(t, ...s), 1 / 0);
  }
  round() {
    return new c(this.rows, this.columns, this.values.map((t) => t.map((s) => Math.round(s))));
  }
  determinant() {
    if (this.rows !== this.columns)
      throw new Error("Dimension error! The matrix isn't squared!");
    if (this.rows === this.columns && this.columns === 1)
      return this.values[0][0];
    let t = 0, s = 1;
    if (this.rows === 2)
      t = this.values[0][0] * this.values[1][1] - this.values[1][0] * this.values[0][1];
    else
      for (let e = 0; e < this.rows; e++) {
        const r = this.getCofactor(0, e);
        t += s * this.at(0, e) * r.determinant(), s = -s;
      }
    return t;
  }
  getCofactor(t, s) {
    return new c(this.rows - 1, this.columns - 1, this.values.filter((e, r) => r !== t).map((e) => e.filter((r, n) => n !== s)));
  }
  transpose() {
    return new c(this.columns, this.rows, new Array(this.columns).fill([]).map((t, s) => new Array(this.rows).fill(0).map((e, r) => this.at(r, s))));
  }
  inverse() {
    if (this.rows !== this.columns)
      throw new Error("Dimension error! The matrix isn't squared!");
    const t = this.determinant();
    if (t === 0)
      throw new Error("Determinant is 0, can't compute inverse.");
    const e = new c(
      this.rows,
      this.columns,
      this.values.map((r, n) => r.map((i, o) => Math.pow(-1, n + o) * this.getCofactor(n, o).determinant()))
    ).transpose();
    return new c(
      this.rows,
      this.columns,
      this.values.map((r, n) => r.map((i, o) => e.at(n, o) / t))
    );
  }
  toString() {
    return `[${this.values.map((t) => `[${t.join(", ")}]`).join(`,
`)}]`;
  }
}
class v {
  constructor(t) {
    m(this, "_values");
    this._values = new Array((t || [0]).length).fill(0), t && (this.values = t);
  }
  get rows() {
    return this.values.length;
  }
  get values() {
    return this._values;
  }
  set values(t) {
    const s = Math.min(this.values.length, t.length);
    for (let e = 0; e < s; e++)
      this.values[e] = t[e];
  }
  angleFrom(t) {
    if (this.rows !== t.rows)
      throw new Error("To calculate the angle, vectors must have the same dimension!");
    const e = this.dot(t) / (this.length() * t.length());
    return Math.acos(e);
  }
  distanceFrom(t) {
    if (this.rows !== t.rows)
      throw new Error("To calculate the distance, vectors must have the same dimension!");
    return this.subtract(t).length();
  }
  at(t) {
    return this.values[t];
  }
  indexOf(t) {
    return this.values.indexOf(t);
  }
  reset() {
    this.values = this.values.fill(0);
  }
  addAValue() {
    return this.values.push(0), new v(this.values);
  }
  equals(t) {
    return this.rows === t.rows && this.values.reduce((s, e, r) => s && t.at(r) === e, !0);
  }
  negate() {
    return new v(this.values.map((t) => -t));
  }
  length() {
    return Math.sqrt(this.squaredLength());
  }
  squaredLength() {
    return this.dot(this);
  }
  add(t) {
    if (this.rows !== t.rows)
      throw new Error("Vectors don't have the same dimension!");
    return this.operateOnAllValues((s, e) => s + t.at(e));
  }
  subtract(t) {
    if (this.rows !== t.rows)
      throw new Error("Vectors don't have the same dimension!");
    return this.operateOnAllValues((s, e) => s - t.at(e));
  }
  multiply(t) {
    if (this.rows !== t.rows)
      throw new Error("Vectors don't have the same dimension!");
    return this.operateOnAllValues((s, e) => s * t.at(e));
  }
  divide(t) {
    if (this.rows !== t.rows)
      throw new Error("Vectors don't have the same dimension!");
    return this.operateOnAllValues((s, e) => t.at(e) === 0 ? s : s / t.at(e));
  }
  max() {
    if (this.rows === 0)
      throw new Error("Cannot get the maximum value of an empty vector!");
    return Math.max(...this.values);
  }
  min() {
    if (this.rows === 0)
      throw new Error("Cannot get the minimum value of an empty vector!");
    return Math.min(...this.values);
  }
  round() {
    if (this.rows === 0)
      throw new Error("Cannot round an empty vector!");
    return this.operateOnAllValues((t) => Math.round(t));
  }
  scale(t) {
    return this.operateOnAllValues((s) => s * t);
  }
  operateOnAllValues(t) {
    return new v(this.values.map(t));
  }
  normalize() {
    const t = this.length();
    return this.operateOnAllValues((s) => s / t);
  }
  dot(t) {
    return this.values.reduce((s, e, r) => s + e * t.at(r), 0);
  }
  cross(t) {
    if (this.rows < 3 || t.rows < 3)
      throw new Error("Cross product is possible on 3D vectors only");
    const s = new Array(3);
    return s[0] = this.at(1) * t.at(2) - this.at(2) * t.at(1), s[1] = this.at(2) * t.at(0) - this.at(0) * t.at(2), s[2] = this.at(0) * t.at(1) - this.at(1) * t.at(0), new v(s);
  }
  mix(t, s) {
    return new v(this.values.map((e, r) => e + s * (t.at(r) - e)));
  }
  static get360angle(t, s) {
    if (t.rows !== 3 || s.rows !== 3)
      throw new Error("Vectors must be in 3D!. You can add a 1 dimension if it is missing.");
    return -Math.atan2(
      s.cross(t).dot(new v([0, 0, 1]).normalize()),
      t.dot(s)
    );
  }
  toString() {
    return `[${this.values.join(", ")}]`;
  }
}
const z = 1e-5, w = class {
  constructor(t) {
    m(this, "values", new Float32Array(4));
    t !== void 0 && (this.xyzw = t);
  }
  get x() {
    return this.values[0];
  }
  set x(t) {
    this.values[0] = t;
  }
  get y() {
    return this.values[1];
  }
  set y(t) {
    this.values[1] = t;
  }
  get z() {
    return this.values[2];
  }
  set z(t) {
    this.values[2] = t;
  }
  get w() {
    return this.values[3];
  }
  set w(t) {
    this.values[3] = t;
  }
  get xy() {
    return [
      this.values[0],
      this.values[1]
    ];
  }
  set xy(t) {
    this.values[0] = t[0], this.values[1] = t[1];
  }
  get xyz() {
    return [
      this.values[0],
      this.values[1],
      this.values[2]
    ];
  }
  set xyz(t) {
    this.values[0] = t[0], this.values[1] = t[1], this.values[2] = t[2];
  }
  get xyzw() {
    return [
      this.values[0],
      this.values[1],
      this.values[2],
      this.values[3]
    ];
  }
  set xyzw(t) {
    this.values[0] = t[0], this.values[1] = t[1], this.values[2] = t[2], this.values[3] = t[3];
  }
  at(t) {
    return this.values[t];
  }
  reset() {
    for (let t = 0; t < 4; t++)
      this.values[t] = 0;
  }
  copy(t) {
    t || (t = new w());
    for (let s = 0; s < 4; s++)
      t.values[s] = this.values[s];
    return t;
  }
  roll() {
    const t = this.x, s = this.y, e = this.z, r = this.w;
    return Math.atan2(2 * (t * s + r * e), r * r + t * t - s * s - e * e);
  }
  pitch() {
    const t = this.x, s = this.y, e = this.z, r = this.w;
    return Math.atan2(2 * (s * e + r * t), r * r - t * t - s * s + e * e);
  }
  yaw() {
    return Math.asin(2 * (this.x * this.z - this.w * this.y));
  }
  equals(t, s = z) {
    for (let e = 0; e < 4; e++)
      if (Math.abs(this.values[e] - t.at(e)) > s)
        return !1;
    return !0;
  }
  setIdentity() {
    return this.x = 0, this.y = 0, this.z = 0, this.w = 1, this;
  }
  calculateW() {
    const t = this.x, s = this.y, e = this.z;
    return this.w = -Math.sqrt(Math.abs(1 - t * t - s * s - e * e)), this;
  }
  inverse() {
    const t = w.dot(this, this);
    if (!t)
      return this.xyzw = [0, 0, 0, 0], this;
    const s = t ? 1 / t : 0;
    return this.x *= -s, this.y *= -s, this.z *= -s, this.w *= s, this;
  }
  conjugate() {
    return this.values[0] *= -1, this.values[1] *= -1, this.values[2] *= -1, this;
  }
  length() {
    const t = this.x, s = this.y, e = this.z, r = this.w;
    return Math.sqrt(t * t + s * s + e * e + r * r);
  }
  normalize(t) {
    t || (t = this);
    const s = this.x, e = this.y, r = this.z, n = this.w;
    let i = Math.sqrt(s * s + e * e + r * r + n * n);
    return i ? (i = 1 / i, t.x = s * i, t.y = e * i, t.z = r * i, t.w = n * i, t) : (t.x = 0, t.y = 0, t.z = 0, t.w = 0, t);
  }
  add(t) {
    for (let s = 0; s < 4; s++)
      this.values[s] += t.at(s);
    return this;
  }
  multiply(t) {
    const s = this.values[0], e = this.values[1], r = this.values[2], n = this.values[3], i = t.x, o = t.y, h = t.z, a = t.w;
    return this.x = s * a + n * i + e * h - r * o, this.y = e * a + n * o + r * i - s * h, this.z = r * a + n * h + s * o - e * i, this.w = n * a - s * i - e * o - r * h, this;
  }
  static dot(t, s) {
    return t.x * s.x + t.y * s.y + t.z * s.z + t.w * s.w;
  }
  static sum(t, s) {
    const e = new w();
    return e.x = t.x + s.x, e.y = t.y + s.y, e.z = t.z + s.z, e.w = t.w + s.w, e;
  }
  static product(t, s) {
    const e = new w(), r = t.x, n = t.y, i = t.z, o = t.w, h = s.x, a = s.y, u = s.z, l = s.w;
    return e.x = r * l + o * h + n * u - i * a, e.y = n * l + o * a + i * h - r * u, e.z = i * l + o * u + r * a - n * h, e.w = o * l - r * h - n * a - i * u, e;
  }
  static cross(t, s) {
    const e = new w(), r = t.x, n = t.y, i = t.z, o = t.w, h = s.x, a = s.y, u = s.z, l = s.w;
    return e.x = o * u + i * l + r * a - n * h, e.y = o * l - r * h - n * a - i * u, e.z = o * h + r * l + n * u - i * a, e.w = o * a + n * l + i * h - r * u, e;
  }
  static shortMix(t, s, e) {
    const r = new w();
    if (e <= 0)
      return r.xyzw = t.xyzw, r;
    if (e >= 1)
      return r.xyzw = s.xyzw, r;
    let n = w.dot(t, s);
    const i = s.copy();
    n < 0 && (i.inverse(), n = -n);
    let o, h;
    if (n > 0.9999)
      o = 1 - e, h = 0 + e;
    else {
      const a = Math.sqrt(1 - n * n), u = Math.atan2(a, n), l = 1 / a;
      o = Math.sin((1 - e) * u) * l, h = Math.sin((0 + e) * u) * l;
    }
    return r.x = o * t.x + h * i.x, r.y = o * t.y + h * i.y, r.z = o * t.z + h * i.z, r.w = o * t.w + h * i.w, r;
  }
  static mix(t, s, e) {
    const r = new w(), n = t.x * s.x + t.y * s.y + t.z * s.z + t.w * s.w;
    if (Math.abs(n) >= 1)
      return r.xyzw = t.xyzw, r;
    const i = Math.acos(n), o = Math.sqrt(1 - n * n);
    if (Math.abs(o) < 1e-3)
      return r.x = t.x * 0.5 + s.x * 0.5, r.y = t.y * 0.5 + s.y * 0.5, r.z = t.z * 0.5 + s.z * 0.5, r.w = t.w * 0.5 + s.w * 0.5, r;
    const h = Math.sin((1 - e) * i) / o, a = Math.sin(e * i) / o;
    return r.x = t.x * h + s.x * a, r.y = t.y * h + s.y * a, r.z = t.z * h + s.z * a, r.w = t.w * h + s.w * a, r;
  }
  static fromAxisAngle(t, s) {
    if (t.rows !== 3)
      throw new Error("The axis vector must be in 3D!");
    const e = new w();
    s *= 0.5;
    const r = Math.sin(s);
    return e.x = t.at(0) * r, e.y = t.at(1) * r, e.z = t.at(2) * r, e.w = Math.cos(s), e;
  }
};
let f = w;
m(f, "identity", new w().setIdentity());
export {
  c as Matrix,
  f as Quat,
  v as Vector
};
//# sourceMappingURL=ts-matrix.mjs.map
