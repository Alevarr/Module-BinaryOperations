{"ast":null,"code":"import { Graph } from './Graph';\nimport { Node } from './Node';\nimport { Edge } from './Edge';\n\n// export class GraphGenerator {\n\n//     public static random<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false){\n//         let graph: Graph<T1, T2> = new Graph()\n//         for (let i = 0; i < n_vertex; i++){\n//             let node: Node<T1> = new Node(i.toString(), i.toString(), \"\")\n//             graph.addNode(node)\n//         }\n//         let edges_ids: number[] = [0]\n//         graph.nodes.forEach(node1 => {\n//             graph.nodes.forEach(node2 => {\n//                 if (node1.id !== node2.id) {\n//                     let prob = Math.random()\n//                     if (p_connected > prob){\n//                         let index = 1\n//                         if (edges_ids && edges_ids.at(-1)){\n//                             index = edges_ids[edges_ids.length - 1] + 1\n//                         }\n//                         edges_ids.push(index)\n//                         let edge: Edge<T1, T2> = new Edge(index.toString(), node1, node2, \"\", \"0\")\n//                         graph.addEdge(edge)\n//                     }\n//                 }\n//             });\n//         });\n//         return graph\n//     }\n\n// }\n\nexport class GraphGenerator {\n  static random(n_vertex, p_connected, selfconn = false) {\n    let graph = new Graph();\n    for (let i = 0; i < n_vertex; i++) {\n      let node = new Node(i.toString(), i.toString(), \"\");\n      graph.addNode(node);\n    }\n\n    // Сгенерируем граф с заданной вероятностью связности\n    let edges_ids = [0];\n    graph.nodes.forEach(node1 => {\n      graph.nodes.forEach(node2 => {\n        if (node1.id !== node2.id) {\n          let prob = Math.random();\n          if (p_connected > prob) {\n            let index = 1;\n            if (edges_ids && edges_ids.at(-1)) {\n              index = edges_ids[edges_ids.length - 1] + 1;\n            }\n            edges_ids.push(index);\n            let edge = new Edge(index.toString(), node1, node2, \"\", \"0\");\n            graph.addEdge(edge);\n          }\n        }\n      });\n    });\n\n    // Проверяем связность графа и добавляем дополнительные ребра, если необходимо\n    while (!this.isConnected(graph)) {\n      let disconnectedNodes = [];\n      graph.nodes.forEach(node => {\n        if (node.edges.length === 0) {\n          disconnectedNodes.push(node);\n        }\n      });\n\n      // Соединяем случайную несвязанную вершину с уже существующей\n      let randomIndex = Math.floor(Math.random() * disconnectedNodes.length);\n      let randomNode = disconnectedNodes[randomIndex];\n      let connectedNodeIndex = Math.floor(Math.random() * graph.nodes.length);\n      let connectedNode = graph.nodes[connectedNodeIndex];\n\n      // Добавляем ребро между случайными вершинами\n      let index = edges_ids[edges_ids.length - 1] + 1;\n      edges_ids.push(index);\n      let edge = new Edge(index.toString(), randomNode, connectedNode, \"\", \"0\");\n      graph.addEdge(edge);\n    }\n    return graph;\n  }\n  static isConnected(graph) {\n    // Мы будем использовать алгоритм обхода в глубину (DFS) для проверки связности графа\n    let visited = {};\n    let startNode = graph.nodes[0];\n    this.dfs(startNode, visited);\n\n    // Проверяем, были ли все вершины посещены\n    for (let node of graph.nodes) {\n      if (!visited[node.id]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static dfs(node, visited) {\n    visited[node.id] = true;\n    for (let edge of node.edges) {\n      let neighbor = edge.node1 === node ? edge.node2 : edge.node1;\n      if (!visited[neighbor.id]) {\n        this.dfs(neighbor, visited);\n      }\n    }\n  }\n}","map":{"version":3,"names":["Graph","Node","Edge","GraphGenerator","random","n_vertex","p_connected","selfconn","graph","i","node","toString","addNode","edges_ids","nodes","forEach","node1","node2","id","prob","Math","index","at","length","push","edge","addEdge","isConnected","disconnectedNodes","edges","randomIndex","floor","randomNode","connectedNodeIndex","connectedNode","visited","startNode","dfs","neighbor"],"sources":["/home/marihuyatnik/ERW/Module-BinaryOperations/src/components/GraphLibrary/GraphGenerator.tsx"],"sourcesContent":["import { Graph } from './Graph';\nimport { Node } from './Node';\nimport { Edge } from './Edge';\n\n\n// export class GraphGenerator {\n    \n//     public static random<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false){\n//         let graph: Graph<T1, T2> = new Graph()\n//         for (let i = 0; i < n_vertex; i++){\n//             let node: Node<T1> = new Node(i.toString(), i.toString(), \"\")\n//             graph.addNode(node)\n//         }\n//         let edges_ids: number[] = [0]\n//         graph.nodes.forEach(node1 => {\n//             graph.nodes.forEach(node2 => {\n//                 if (node1.id !== node2.id) {\n//                     let prob = Math.random()\n//                     if (p_connected > prob){\n//                         let index = 1\n//                         if (edges_ids && edges_ids.at(-1)){\n//                             index = edges_ids[edges_ids.length - 1] + 1\n//                         }\n//                         edges_ids.push(index)\n//                         let edge: Edge<T1, T2> = new Edge(index.toString(), node1, node2, \"\", \"0\")\n//                         graph.addEdge(edge)\n//                     }\n//                 }\n//             });\n//         });\n//         return graph\n//     }\n\n// }\n\nexport class GraphGenerator {\n    \n    public static random<T1, T2>(n_vertex: number, p_connected: number, selfconn: boolean = false){\n        let graph: Graph<T1, T2> = new Graph()\n        for (let i = 0; i < n_vertex; i++){\n            let node: Node<T1> = new Node(i.toString(), i.toString(), \"\")\n            graph.addNode(node)\n        }\n\n        // Сгенерируем граф с заданной вероятностью связности\n        let edges_ids: number[] = [0]\n        graph.nodes.forEach(node1 => {\n            graph.nodes.forEach(node2 => {\n                if (node1.id !== node2.id) {\n                    let prob = Math.random()\n                    if (p_connected > prob){\n                        let index = 1\n                        if (edges_ids && edges_ids.at(-1)){\n                            index = edges_ids[edges_ids.length - 1] + 1\n                        }\n                        edges_ids.push(index)\n                        let edge: Edge<T1, T2> = new Edge(index.toString(), node1, node2, \"\", \"0\")\n                        graph.addEdge(edge)\n                    }\n                }\n            });\n        });\n\n        // Проверяем связность графа и добавляем дополнительные ребра, если необходимо\n        while (!this.isConnected(graph)) {\n            let disconnectedNodes: Node<T1>[] = []\n            graph.nodes.forEach(node => {\n                if (node.edges.length === 0) {\n                    disconnectedNodes.push(node)\n                }\n            })\n\n            // Соединяем случайную несвязанную вершину с уже существующей\n            let randomIndex = Math.floor(Math.random() * disconnectedNodes.length)\n            let randomNode = disconnectedNodes[randomIndex]\n            let connectedNodeIndex = Math.floor(Math.random() * graph.nodes.length)\n            let connectedNode = graph.nodes[connectedNodeIndex]\n\n            // Добавляем ребро между случайными вершинами\n            let index = edges_ids[edges_ids.length - 1] + 1\n            edges_ids.push(index)\n            let edge: Edge<T1, T2> = new Edge(index.toString(), randomNode, connectedNode, \"\", \"0\")\n            graph.addEdge(edge)\n        }\n\n        return graph\n    }\n\n    private static isConnected<T1, T2>(graph: Graph<T1, T2>): boolean {\n        // Мы будем использовать алгоритм обхода в глубину (DFS) для проверки связности графа\n        let visited: {[key: string]: boolean} = {}\n        let startNode = graph.nodes[0]\n        this.dfs(startNode, visited)\n\n        // Проверяем, были ли все вершины посещены\n        for (let node of graph.nodes) {\n            if (!visited[node.id]) {\n                return false\n            }\n        }\n        return true\n    }\n\n    private static dfs<T1, T2>(node: Node<T1>, visited: {[key: string]: boolean}) {\n        visited[node.id] = true\n        for (let edge of node.edges) {\n            let neighbor = edge.node1 === node ? edge.node2 : edge.node1\n            if (!visited[neighbor.id]) {\n                this.dfs(neighbor, visited)\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}